---
title: Web Proxy
date: 2025-10-07 11:00:00 +0000
categories: [Web, apuntes]
tags: [HTTP, web, proxy]
image:
  path: /assets/img/posts/web-proxies/web_proxy_banner.png
  alt: cabecera
description: >
  Web Proxy

pin: false  
toc: true   
math: false 
mermaid: false 
---


Las pruebas de solicitudes web a servidores back-end constituyen la mayor parte de las pruebas de penetración de aplicaciones web, que incluyen conceptos que se aplican tanto a aplicaciones web como móviles. Para capturar las solicitudes y el tráfico que pasa entre las aplicaciones y los servidores back-end y manipular este tipo de solicitudes con fines de prueba, necesitamos utilizar proxies.

Los proxies web son herramientas especializadas que se pueden configurar entre un navegador/aplicación móvil y un servidor back-end para capturar y ver todas las solicitudes web que se envían entre ambos extremos, actuando esencialmente como herramientas man-in-the-middle (MITM). 
Mientras que otras aplicaciones de rastreo de redes, como Wireshark, funcionan analizando todo el tráfico local para ver qué pasa por una red, los proxies web trabajan principalmente con puertos web como, entre otros, HTTP/80 y HTTPS/443.

Se consideran una de las herramientas más esenciales para cualquier pentester web. Simplifican significativamente el proceso de captura y reproducción de solicitudes web en comparación con las herramientas anteriores basadas en CLI. Una vez configurado un proxy web, podemos ver todas las solicitudes HTTP realizadas por una aplicación y todas las respuestas enviadas por el servidor back-end. Además, podemos interceptar una solicitud específica para modificar sus datos y ver cómo los gestiona el servidor back-end, lo cual es una parte esencial.


#### Manipulación de solicitudes interceptadas

Una vez que interceptamos la solicitud, permanecerá en espera hasta que la reenviemos. Podemos examinar la solicitud, manipularla para realizar los cambios que queramos y, a continuación, enviarla a su destino. Esto nos ayuda a comprender mejor qué información envía una aplicación web concreta en sus solicitudes web y cómo puede responder a cualquier cambio que realicemos en dicha solicitud.

Existen numerosas aplicaciones para esto testear la seguridad, tales como pruebas para:

1. SQL injections
2. Command injections
3. Upload bypass
4. Authentication bypass
5. XSS
6. XXE
7. Error handling
8. Deserialization

#### Interceptación

En algunos casos, es posible que necesitemos interceptar las respuestas HTTP del servidor antes de que lleguen al navegador. Esto puede resultar útil cuando queremos cambiar el aspecto de una página web específica, como habilitar ciertos campos desactivados o mostrar ciertos campos ocultos, lo que puede ayudarnos en nuestras pruebas.

En Burp, podemos habilitar la interceptación de respuestas yendo a (Proxy>Configuración del proxy) y habilitando Interceptar respuesta en Reglas de interceptación de respuestas.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006202852.png)

Burp también tiene una función que podemos habilitar en Proxy>Configuración del proxy>Reglas de modificación de la respuesta, y luego seleccionar una de las opciones, como Mostrar campos ocultos del formulario.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006203912.png)

La posibilidad de modificar el aspecto de la página web nos facilita mucho la realización de pruebas de aplicaciones web en determinados escenarios, en lugar de tener que enviar nuestra entrada a través de una solicitud interceptada. 

#### Modificación automática de peticiones.

Podemos elegir hacer coincidir cualquier texto dentro de nuestras solicitudes, ya sea en el encabezado o en el cuerpo de la solicitud, y luego sustituirlo por un texto diferente.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006204137.png)

Podemos ir a (Proxy > Configuración del proxy > Reglas de coincidencia y sustitución HTTP) y hacer clic en Añadir en Burp.


#### Modificación de respuesta automática

Volvamos a (Proxy>Opciones>Buscar y reemplazar) en Burp para añadir otra regla. Esta vez utilizaremos el tipo de cuerpo de respuesta, ya que el cambio que queremos realizar se encuentra en el cuerpo de la respuesta y no en sus encabezados. En este caso, no es necesario utilizar expresiones regulares, ya que sabemos exactamente qué cadena queremos reemplazar, aunque es posible utilizar expresiones regulares para hacer lo mismo si lo preferimos.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006204937.png)


### URL Encoding

Es esencial asegurarse de que los datos de nuestra solicitud estén codificados en URL y que los encabezados de nuestra solicitud estén configurados correctamente. De lo contrario, podríamos obtener un error del servidor en la respuesta. Por eso, la codificación y descodificación de datos se vuelven esenciales a medida que modificamos y repetimos las solicitudes web. 

- **Espacios**: pueden indicar el final de los datos de la solicitud si no están codificados. 
- **&:** se interpreta como un delimitador de parámetros. 
- **#:** se interpreta como un identificador de fragmento.

Para codificar texto en URL en Burp Repeater, podemos seleccionar el texto y hacer clic con el botón derecho del ratón sobre él, luego seleccionar (Convertir selección>URL>Codificar caracteres clave en URL), o seleccionar el texto y pulsar [CTRL+U].

Burp también admite la codificación de URL mientras escribimos si hacemos clic con el botón derecho y habilitamos esa opción, lo que codificará todo nuestro texto a medida que lo escribimos.


### Decodificación

Es muy habitual que las aplicaciones web codifiquen sus datos, por lo que debemos ser capaces de descodificarlos rápidamente para examinar el texto original. Por otro lado, los servidores back-end pueden esperar que los datos estén codificados en un formato concreto o con un codificador específico, por lo que debemos ser capaces de codificar rápidamente nuestros datos antes de enviarlos.

- HTML
- Unicode
- Base64
- ASCII hex


### Proxying tools

Para enrutar todas las solicitudes web realizadas por una herramienta específica a través de nuestras herramientas de proxy web, tenemos que configurarlas como el proxy de la herramienta (es decir, http://127.0.0.1:8080), de forma similar a lo que hicimos con nuestros navegadores. 
Cada herramienta puede tener un método diferente para configurar su proxy, por lo que es posible que tengamos que investigar cómo hacerlo para cada una de ellas. 


#### Proxychains

Una herramienta muy útil en Linux es proxychains, que redirige todo el tráfico procedente de cualquier herramienta de línea de comandos a cualquier proxy que especifiquemos. 

Proxychains añade un proxy a cualquier herramienta de línea de comandos y, por lo tanto, es el método más sencillo y fácil para redirigir el tráfico web de las herramientas de línea de comandos a través de nuestros proxies web.

Para utilizar proxychains, primero tenemos que editar /etc/proxychains.conf, comentar la última línea y añadir la siguiente línea al final del archivo:

```shell-session
#socks4         127.0.0.1 9050
http 127.0.0.1 8080
```

También debemos utilizar la opción -q, que hace que proxychains funcione en modo «silencioso», suprimiendo la salida de información de conexión a la consola. 


#### Metasploit

Debemos comenzar iniciando Metasploit con msfconsole. A continuación, para configurar un proxy para cualquier exploit dentro de Metasploit, podemos utilizar el indicador set PROXIES. 

Probemos el escáner robots_txt como ejemplo y ejecutémoslo.

```shell-session
$ msfconsole

msf6 > use auxiliary/scanner/http/robots_txt
msf6 auxiliary(scanner/http/robots_txt) > set PROXIES HTTP:127.0.0.1:8080

PROXIES => HTTP:127.0.0.1:8080


msf6 auxiliary(scanner/http/robots_txt) > set RHOST SERVER_IP

RHOST => SERVER_IP


msf6 auxiliary(scanner/http/robots_txt) > set RPORT PORT

RPORT => PORT


msf6 auxiliary(scanner/http/robots_txt) > run

[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
```

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006212404.png)

Del mismo modo, podemos utilizar nuestros proxies web con otras herramientas y aplicaciones, incluidos scripts. Todo lo que tenemos que hacer es configurar el proxy de cada herramienta para que utilice nuestro proxy web. Esto nos permite examinar exactamente lo que estas herramientas envían y reciben, y potencialmente repetir y modificar sus solicitudes mientras realizamos pruebas de aplicaciones web.


#### Fuzzing

Hacemos clic con el botón derecho del ratón en la solicitud y seleccione Enviar a Intruder, o utilice el atajo [CTRL+I] para enviarla a Intruder.

«Posiciones» es donde colocamos el puntero de posición de la carga útil, que es el punto donde se colocarán y se iterarán las palabras de nuestra lista de palabras. Demostraremos cómo realizar fuzzing en directorios web, lo cual es similar a lo que hacen herramientas como ffuf o gobuster.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006214318.png)

En la sección «Payloads» (Cargas útiles) situada a la derecha, podemos elegir y personalizar nuestras cargas útiles/listas de palabras. Esta carga útil/lista de palabras es lo que se repetirá, y cada elemento/línea de la misma se colocará y probará uno por uno en la posición de carga útil que hayamos elegido anteriormente. Hay cuatro aspectos principales que debemos configurar:

- Payload Position & Payload Type
- Payload Configuration
- Payload Processing
- Payload Encoding

#### Payload Position & Payload Type

Lo primero que debemos configurar es la posición y el tipo de carga útil. El conjunto de cargas útiles identifica el número de carga útil, dependiendo del tipo de ataque y del número de cargas útiles que hayamos utilizado en los punteros de posición de carga útil.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006214744.png)

En este caso, solo tenemos una posición de carga útil, ya que hemos elegido el tipo de ataque «sniper» con una sola posición de carga útil. Si hubiéramos elegido el tipo de ataque «Cluster Bomb», por ejemplo, y hubiéramos añadido varias posiciones de carga útil, tendríamos más posiciones de carga útil entre las que elegir y podríamos seleccionar diferentes opciones para cada una.

A continuación, debemos seleccionar el tipo de carga útil, que es el tipo de cargas útiles/listas de palabras que utilizaremos. 

- **Simple list**: el tipo básico y más fundamental. Proporcionamos una lista de palabras e Intruder repite cada línea de la misma.
- **Runtime file**: similar a la lista simple, pero se carga línea por línea a medida que se ejecuta el análisis para evitar un uso excesivo de memoria por parte de Burp.
- **Character Substitution**: nos permite especificar una lista de caracteres y sus sustituciones, y Burp Intruder prueba todas las permutaciones posibles.


#### Payload Configuration

A continuación, debemos especificar la configuración de la carga útil, que es diferente para cada tipo de carga útil que seleccionemos en Payload Type. Para una lista simple, tenemos que crear o cargar una lista de palabras. Para ello, podemos introducir cada elemento manualmente haciendo clic en Añadir, lo que crearía nuestra lista de palabras sobre la marcha. La otra opción más común es hacer clic en Cargar y, a continuación, seleccionar un archivo para cargarlo en Burp Intruder.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006215527.png)

Podemos añadir otra lista de palabras o añadir manualmente algunos elementos, y se añadirán a la misma lista de elementos. Podemos utilizar esto para combinar varias listas de palabras o crear listas de palabras personalizadas. En Burp Pro, también podemos seleccionar una lista de listas de palabras existentes contenidas en Burp eligiendo la opción del menú Añadir desde la lista.

#### Payload Processing

Nos permite determinar reglas de fuzzing sobre la lista de palabras cargada. Por ejemplo, si quisiéramos añadir una extensión después de nuestro elemento de carga útil, o si quisiéramos filtrar la lista de palabras según criterios específicos, podríamos hacerlo con el procesamiento de la carga útil.

Probemos a añadir una regla que omita cualquier línea que comience por . Para ello, hacemos clic en el botón Añadir y seleccionamos Omitir si coincide con la expresión regular, lo que nos permite proporcionar un patrón de expresión regular para los elementos que queremos omitir. A continuación, podemos proporcionar un patrón de expresión regular que coincida con las líneas que comienzan por ., que es: ^\..*$:

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006220116.png)
![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006220156.png)

#### Payload Encoding

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006220310.png)

#### Settings

Por último, podemos personalizar nuestras opciones de ataque desde la pestaña Configuración. Hay muchas opciones que podemos personalizar (o dejar por defecto) para nuestro ataque. Por ejemplo, podemos establecer el Número de reintentos en caso de fallo de red y la Pausa antes de reintentar en 0.

Otra opción útil es Grep - Match, que nos permite marcar solicitudes específicas en función de sus respuestas. Como estamos realizando fuzzing en directorios web, solo nos interesan las respuestas con el código HTTP 200 OK. Por lo tanto, primero lo habilitaremos y luego haremos clic en Clear para borrar la lista actual. A continuación, podemos escribir 200 OK para buscar cualquier solicitud que contenga esta cadena y hacer clic en Add para añadir la nueva regla. Por último, también desactivaremos Exclude HTTP Headers, ya que lo que buscamos está en el encabezado HTTP.

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006220714.png)

También podemos utilizar la opción Grep - Extract, que resulta útil si las respuestas HTTP son largas y solo nos interesa una parte concreta de la respuesta. De este modo, solo se muestra una parte específica de la respuesta.


#### Attack

![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006221116.png)
![web](/assets/img/posts/web-proxies/Pasted%20image%2020251006221133.png)

Del mismo modo, podemos utilizar Burp Intruder para realizar cualquier tipo de fuzzing y fuerza bruta web, incluyendo la fuerza bruta para contraseñas o el fuzzing para determinados parámetros PHP, etc. 

Incluso podemos utilizar Intruder para realizar ataques de contraseñas contra aplicaciones que utilizan la autenticación de Active Directory (AD), como Outlook Web Access (OWA), portales SSL VPN, Servicios de Escritorio Remoto (RDS), Citrix, aplicaciones web personalizadas que utilizan la autenticación AD, y mucho más.

### Extensiones

Tanto Burp como ZAP tienen capacidades de extensión, de modo que la comunidad de usuarios de Burp puede desarrollar extensiones para Burp que todos puedan utilizar. Dichas extensiones pueden realizar acciones específicas en cualquier solicitud capturada, por ejemplo, o añadir nuevas funciones, como decodificar y embellecer el código. Burp permite la extensibilidad a través de su función Extender y su BApp Store, mientras que ZAP tiene su ZAP Marketplace para instalar nuevos complementos.

##### BApp Store

Para encontrar todas las extensiones disponibles, podemos hacer clic en la pestaña Extender dentro de Burp y seleccionar la subpestaña BApp Store. Una vez hecho esto, veremos una gran cantidad de extensiones. Podemos ordenarlas por popularidad para saber cuáles son las que los usuarios consideran más útiles.

Para encontrar todas las extensiones disponibles, podemos hacer clic en la pestaña Extender dentro de Burp y seleccionar la subpestaña BApp Store. Una vez hecho esto, veremos una gran cantidad de extensiones. Podemos ordenarlas por popularidad para saber cuáles son las que los usuarios consideran más útiles:

Algunas extensiones que vale la pena revisar incluyen, entre otras:

|   |   |   |
|---|---|---|
|.NET Beautifier|J2EEScan|Software Vulnerability Scanner|
|Software Version Reporter|Active Scan++|Additional Scanner Checks|
|AWS Security Checks|Backslash Powered Scanner|Wsdler|
|Java Deserialization Scanner|C02|Cloud Storage Tester|
|CMS Scanner|Error Message Checks|Detect Dynamic JS|
|Headers Analyzer|HTML5 Auditor|PHP Object Injection Check|
|JavaScript Security|Retire.JS|CSP Auditor|
|Random IP Address Header|Autorize|CSRF Scanner|
|JS Link Finder|||